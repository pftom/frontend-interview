## 浏览器原理


问：CDN 原理


CDN （内容分发网络），将源站的内容分发到里用户最近网络的边缘，使得用户可以就近获取数据，不仅降低了网络的拥塞状态，提高了响应速度，还可以减轻源站的负载压力


## 问：V8 内存回收机制


- 标记清除
- 引用计数



### 标记清除


当变量进入环境，就将变量标记为 “进入环境”，当变量离开环境，则将变量标志为 “离开环境”


- 垃圾收集器（GC）会给存储在内存中的变量打上标记
- 然后，去除运行环境中的变量以及被环境中所引用变量的标记
- 此后，依然有标记的变量被视为准备删除的变量
- 最后，垃圾收集器完成内存清除工作，销毁那些带标记的值然后回收它们占用的内存空间



### 引用计数


每被引用一次就 +1， 删除引用就 -1，引用次数为0就代表要被回收，会有循环引用问题


### 参考链接


- [https://juejin.im/post/5ad3f1156fb9a028b86e78be](https://juejin.im/post/5ad3f1156fb9a028b86e78be)



## （6）问：`localstorage`、`sessionstorage`、`indexedDB` ， `cookie` 的区别


- cookie 本来是用来为 HTTP 添加状态支持的，用于标志浏览器身份，具有 4 KB 容量，跟随域名，参与服务器通信，也就是每次网络请求都会浏览器端都会带上 cookie，且是明文传输，不仅带来了极大的性能开销，还为 XSS 和 CSRF 埋下祸根
- localStorage 有 5M 可以存储一些 Logo 或者 base 图片资源，且是持久化存储，而且只存在客户端不参与与服务器端通信，暴露在全局 API ，很方便使用
- SessionStorage 其他和 localStorage 一致，不过处于一次会话期间
- indexedDB 是浏览器端的真正的数据库，非关系型基于键值对的存储，默认容量无限多，支持事务，存储二进制数据，有同源策略，不能影响跨域数据库，异步操作本质上属于 I/O



（5）问：跨域问题如何解决

## （3）问：从地址栏输入地址到用户看到东西，经过了什么



首先是和网络有关的过程：构建请求、查找强缓存、然后创建 TCP 连接，发送 HTTP 请求，然后获取响应（如果是 Content-Type 是 text/html）那么则开始解析和渲染过程：

然后解析过程：构建 DOM 树，样式计算，生成 DOM 树

然后开始渲染过程：构建图层树，生成绘制列表，（以上是浏览器主线程）

生成图块（合成线程）和生成位图（栅格化线程池），合成线程生成绘制命令，发送给浏览器进程，浏览器的绘制命令将页面绘制到内存，然后发送给显卡，显示器显示内容

问：浏览器请求数据问题，请求数据到请求结束与服务器进行了几次交互

## 问：cookie有哪些属性、大小、浏览器如何禁止别人访问cookie


- 存在浏览器的文本文件里面
- 跟随域名的，每次都会发送
- 4KB
- 明文传输



如何禁止：


- 设置 HttpOnly 为 true，这样 JS 无法访问
- 设置 Cookie 中 Same-Site 属性，
   - Strict：任何情况下都不带 Cookie
   - Lax：GET 表单，GET a 标签
   - None：任何情况下都带 Cookie



## 问：jsonp 和 ajax 的原理


- json 通过动态添加 script 标签调用服务器端提供的 JS 脚本，来进行资源的获取
- ajax 核心是通过 XmlHttpRequest 来获取非本页内容，不一定是 JSON 格式的，也可以处理跨域



### 参考链接


- [https://www.jianshu.com/p/fce33a35a0b6](https://www.jianshu.com/p/fce33a35a0b6)
## 问：说下浏览器的同源策略，为什么要有这种同源策略？


同源策略就是指，浏览器访问资源时，需要 “协议+域名+端口+ 都相同，才算同源，才能访问资源。


- 具体表现就是 cookie、localStorage 和 IndexedDB 无法读取
- DOM 和 JS 对象无法获得
- Ajax 请求不能发送



为什么要有同源策略？


- 减少被 XSS 或者 CSRF 攻击的可能性



## 跨域解决方案（9种）


- 通过 jsonp 跨域
- document.domain + iframe 跨域
- location.hash + iframe 跨域
- window.name + iframe 跨域 
- window.postMessage 跨域 （HTML5）
- 跨域资源共享（CORS）
- nginx 代理跨域
- nodejs 中间件跨域
- WebSocket 协议跨域



### 参考链接


- [https://segmentfault.com/a/1190000011145364](https://segmentfault.com/a/1190000011145364)



## （2）问：cookie 和 session 区别




- Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
- Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。



### 参考链接


- [https://www.zhihu.com/question/19786827](https://www.zhihu.com/question/19786827)



## 问：cookie 怎么实现


`Cookie`定义了一些[HTTP请求头和HTTP响应头](http://itbilu.com/other/relate/EJ3fKUwUx.html)，通过这些HTTP头信息使服务器可以与客户进行状态交互。
客户端请求服务器后，如果服务器需要记录用户状态，服务器会在响应信息中包含一个`Set-Cookie`的响应头，客户端会根据这个响应头存储`Cookie`信息。再次请求服务器时，客户端会在请求信息中包含一个`Cookie`请求头，而服务器会根据这个请求头进行用户身份、状态等较验。


### 参考链接


- [https://itbilu.com/other/relate/4J4n8fIPe.html](https://itbilu.com/other/relate/4J4n8fIPe.html)



## （2）问：浏览器缓存


- 强缓存（不需要发送 HTTP）
- 协商缓存（发送 HTTP）



浏览器中缓存分为两种，一种强缓存一种协商缓存。


### 强缓存


强缓存不需要发送 HTTP 请求，直接获取，具体通过以下几种情况来检查：


- Http/1.0 使用 Expires 字段记录服务器端的过期时间
- Http/1.1 使用 Cache-Control 的 max-age 字段，过期时长来检查
- 当然 Cache-Control 还可以设置几个其他的值
   - no-cache：直接跳过强缓存，进入协商缓存阶段
   - no-control：不使用任何缓存
   - private：不允许中间服务器缓存
   - public：浏览器和中间服务器都可以缓存
   - s-maxags：中间服务器缓存的过期时长



当 Expires 和 Cache-Control 同时存在时，Cache-Control 优先级更高。


### 协商缓存


发起 HTTP 请求，在请求头中携带 缓存 tag 来向服务器发生请求，服务器根据 tag 来觉得是否使用缓存，这个就是协商缓存。


这个 tag 有两种：


- Last-Modified，在请求头中加入 If-Modified-Since 具体记录了 Expires，如果请求头中的值小于服务器端相应的最后修改时间，那么就要更新内容，与具体的 HTTP 请求响应流程一致，否则返回 304，告诉浏览器直接用缓存
- Etag：是服务器根据当前文件的内容，生成 hash 标志，如果内容变，那么 hash 会变，服 务器通过响应头将这个标志给浏览器，下次请求将这个值作为 If-None-Match 这个字段内容作为请求体发送给服务器，服务器收到后，如果内容一致就 304，用缓存，不一致返回新的资源。





### 缓存位置： 


- Service Worker Cache：Service Worker，独立于主线程，不可直接操作 DOM，但是提供了 网络代理，离线缓存和消息推送等功能
- Memory Cache：渲染进程结束后就失效了
- Disk Cache：大的 JS/CSS 等用，存储在磁盘上，如果内存快满了
- Push Cache：Http/2



## 问：页面渲染的过程


- 为了 3D 动画效果能够运行，还需要建立图层树
- 接着渲染引擎根据图层生成一系列绘制列表
- 然后浏览器进程通知合成线程，交给它绘制
- 合成线程将视口页面拆分成一个个 256 或者 512 大小的图块，因为图块的绘制可能会消耗大量时间，所以浏览器一般会先绘制一个低分辨率图，之后等合成线程将图块内容完整绘制完毕之后会替换这个低分辨率图，这是首屏绘制加速的一个收到
- 在渲染进程中，还维护了一个栅格化线程池，合成线程会将视口附近的图块交给栅格化线程吃生成位图，这个过程使用  GPU 加速
- 最后栅格化操作完成后, 合成线程会生成一个绘制命令,发生给浏览器进程,
- 浏览器进程的 viz 组件收到这个命令之后,将页面绘制进内存,然后发送给显卡
- 接着放入通过显卡缓存的后缓冲区,然后显卡中前后缓冲去交换,显示器显示页面





## 参考资料


- [https://juejin.im/post/5d89798d6fb9a06b102769b1](https://juejin.im/post/5d89798d6fb9a06b102769b1)
